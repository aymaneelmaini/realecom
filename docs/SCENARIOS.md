
# Scenarios generated by claude

# E-Commerce - All Scenarios

---

## Scenario 1: Create Product

```
Admin
  |
  v
POST /products {name, description, price}
  |
  v
ProductService.createProduct()
  |
  v
Product entity created
  |
  v
DB: INSERT INTO product_schema.products
  |
  v
Return: 200 OK {productId, name, price}
```

**Endpoint:** `POST /products`

**Request:**
```json
{
  "name": "iPhone 15",
  "description": "Latest iPhone",
  "price": {
    "amount": 999.99,
    "currency": "USD"
  }
}
```

**Response:** `200 OK`
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "iPhone 15",
  "price": {
    "amount": 999.99,
    "currency": "USD"
  }
}
```

---

## Scenario 2: Get All Products

```
Customer
  |
  v
GET /products
  |
  v
ProductService.getAllProducts()
  |
  v
DB: SELECT * FROM product_schema.products
  |
  v
Return: 200 OK {products: []}
```

**Endpoint:** `GET /products`

**Response:** `200 OK`
```json
{
  "products": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "name": "iPhone 15",
      "price": {
        "amount": 999.99,
        "currency": "USD"
      }
    }
  ]
}
```

---

## Scenario 3: Create Inventory

```
Admin
  |
  v
POST /inventories {productId, quantity: 100}
  |
  v
InventoryService.createInventory()
  |
  v
Inventory entity created
  |
  v
DB: INSERT INTO inventory_schema.inventories
     {available: 100, reserved: 0}
  |
  v
Return: 200 OK {inventoryId, available: 100}
```

**Endpoint:** `POST /inventories`

**Request:**
```json
{
  "productId": "550e8400-e29b-41d4-a716-446655440000",
  "quantity": 100
}
```

**Response:** `200 OK`
```json
{
  "id": "660e8400-e29b-41d4-a716-446655440001",
  "productId": "550e8400-e29b-41d4-a716-446655440000",
  "availableQuantity": 100,
  "reservedQuantity": 0
}
```

---

## Scenario 4: Check Inventory

```
Customer
  |
  v
GET /inventories/{productId}
  |
  v
InventoryService.getInventory(productId)
  |
  v
DB: SELECT * FROM inventory_schema.inventories
    WHERE product_id = ?
  |
  v
Return: 200 OK {available: 95, reserved: 5}
```

**Endpoint:** `GET /inventories/{productId}`

**Response:** `200 OK`
```json
{
  "id": "660e8400-e29b-41d4-a716-446655440001",
  "productId": "550e8400-e29b-41d4-a716-446655440000",
  "availableQuantity": 95,
  "reservedQuantity": 5
}
```

---

## Scenario 5: Create Order (Happy Path)

```
Customer
  |
  v
POST /orders {productId, quantity: 5}
  |
  v
OrderService.createOrder()
  |
  +-----> InventoryService.reserve(productId, 5)
  |         |
  |         v
  |         DB: SELECT * WHERE product_id = ? FOR UPDATE
  |         (optimistic lock with version)
  |         |
  |         v
  |         Check: available (95) >= 5 ✓
  |         |
  |         v
  |         DB: UPDATE inventory
  |            SET available=90, reserved=10, version++
  |            WHERE product_id=? AND version=?
  |         |
  |         v
  |         Return: Success
  |
  +-----> DB: INSERT INTO order_schema.orders
  |        {id, status: RESERVED, version: 0}
  |
  +-----> PaymentService.processPayment(orderId, 4999.95, idempotencyKey)
  |         |
  |         v
  |         DB: SELECT * FROM payment_schema.payments
  |            WHERE idempotency_key = ?
  |            (Check if already processed)
  |         |
  |         v
  |         Call external payment API
  |         |
  |         v
  |         DB: INSERT payment {status: SUCCESS}
  |         |
  |         v
  |         Return: Success
  |
  +-----> DB: UPDATE order SET status=PAID, version++
  |
  +-----> PublishEvent(OrderPaid)
  |
  v
Return: 200 OK {orderId, status: PAID, totalPrice: 4999.95}
```

**Endpoint:** `POST /orders`

**Request:**
```json
{
  "productId": "550e8400-e29b-41d4-a716-446655440000",
  "quantity": 5
}
```

**Response:** `200 OK`
```json
{
  "id": "770e8400-e29b-41d4-a716-446655440002",
  "status": "PAID",
  "quantity": 5,
  "totalPrice": {
    "amount": 4999.95,
    "currency": "USD"
  },
  "createdAt": "2025-02-14T10:30:00Z"
}
```

---

## Scenario 6: Order Fails - Insufficient Inventory

```
Customer
  |
  v
POST /orders {productId, quantity: 100}
  |
  v
OrderService.createOrder()
  |
  +-----> InventoryService.reserve(productId, 100)
  |         |
  |         v
  |         DB: SELECT * WHERE product_id = ?
  |         |
  |         v
  |         Check: available (95) >= 100 ✗
  |         |
  |         v
  |         Return: FAILED
  |
  +-----> DB: INSERT order {status: FAILED, reason: "..."}
  |
  +-----> PublishEvent(OrderFailed)
  |
  v
Return: 400 Bad Request {reason: "Insufficient inventory"}
```

**Endpoint:** `POST /orders`

**Request:**
```json
{
  "productId": "550e8400-e29b-41d4-a716-446655440000",
  "quantity": 100
}
```

**Response:** `400 Bad Request`
```json
{
  "error": "Insufficient inventory",
  "availableQuantity": 95,
  "requestedQuantity": 100
}
```

---

## Scenario 7: Order Fails - Payment Rejected (Compensation)

```
Customer
  |
  v
POST /orders {productId, quantity: 5}
  |
  v
OrderService.createOrder()
  |
  +-----> InventoryService.reserve(productId, 5) → Success
  |
  +-----> DB: INSERT order {status: RESERVED}
  |
  +-----> PaymentService.processPayment(...)
  |         |
  |         v
  |         External payment API returns: FAILED
  |         |
  |         v
  |         DB: INSERT payment {status: FAILED}
  |         |
  |         v
  |         Return: FAILED
  |
  +-----> InventoryService.release(productId, 5)  [COMPENSATION]
  |         |
  |         v
  |         DB: UPDATE inventory
  |            SET available=95, reserved=5, version++
  |            WHERE product_id=? AND version=?
  |         |
  |         v
  |         Return: Success
  |
  +-----> DB: UPDATE order {status: FAILED, reason: "Payment rejected"}
  |
  +-----> PublishEvent(OrderFailed)
  |
  v
Return: 400 Bad Request {reason: "Payment failed"}
```

**Endpoint:** `POST /orders`

**Request:**
```json
{
  "productId": "550e8400-e29b-41d4-a716-446655440000",
  "quantity": 5
}
```

**Response:** `400 Bad Request`
```json
{
  "error": "Payment failed",
  "orderId": "770e8400-e29b-41d4-a716-446655440003",
  "status": "FAILED"
}
```

---

## Scenario 8: Concurrent Orders (Race Condition - Same Product)

```
User 1                          User 2
  |                               |
  v                               v
POST /orders {qty: 5}      POST /orders {qty: 5}
  |                               |
  +-----> OrderService #1 <-------+
  |         |
  +-----> InventoryService.reserve(5) [User1]
  |         |
  |         v
  |         DB: SELECT * ... (available: 10, version: 5)
  |         |
  +-----> InventoryService.reserve(5) [User2]
  |         |
  |         v
  |         DB: SELECT * ... (available: 10, version: 5)
  |         |
  +-----> User1: UPDATE inventory
  |         SET available=5, reserved=5, version=6
  |         WHERE version=5 ✓ SUCCESS
  |
  +-----> User2: UPDATE inventory
  |         SET available=5, reserved=5, version=6
  |         WHERE version=5 ✗ FAIL (version is now 6)
  |
  v                               v
200 OK {orderId1, PAID}    400 Error {Insufficient inventory}
```

**Key Point:** Optimistic locking prevents overselling. Second request fails immediately.

---

## Scenario 9: Get Order Status

```
Customer
  |
  v
GET /orders/{orderId}
  |
  v
OrderService.getOrder(orderId)
  |
  v
DB: SELECT * FROM order_schema.orders
    WHERE id = ?
  |
  v
Return: 200 OK {order details}
```

**Endpoint:** `GET /orders/{orderId}`

**Response:** `200 OK`
```json
{
  "id": "770e8400-e29b-41d4-a716-446655440002",
  "status": "PAID",
  "quantity": 5,
  "totalPrice": {
    "amount": 4999.95,
    "currency": "USD"
  },
  "createdAt": "2025-02-14T10:30:00Z"
}
```

---

## Scenario 10: List All Orders

```
Customer
  |
  v
GET /orders
  |
  v
OrderService.getAllOrders()
  |
  v
DB: SELECT * FROM order_schema.orders
  |
  v
Return: 200 OK {orders: []}
```

**Endpoint:** `GET /orders`

**Response:** `200 OK`
```json
{
  "orders": [
    {
      "id": "770e8400-e29b-41d4-a716-446655440002",
      "status": "PAID",
      "quantity": 5,
      "totalPrice": {
        "amount": 4999.95,
        "currency": "USD"
      },
      "createdAt": "2025-02-14T10:30:00Z"
    },
    {
      "id": "880e8400-e29b-41d4-a716-446655440003",
      "status": "FAILED",
      "quantity": 10,
      "totalPrice": null,
      "createdAt": "2025-02-14T10:31:00Z"
    }
  ]
}
```

---

## Summary Table

| Scenario | Endpoint | Method | Status |
|----------|----------|--------|--------|
| 1. Create Product | `/products` | POST | 200 OK |
| 2. Get All Products | `/products` | GET | 200 OK |
| 3. Create Inventory | `/inventories` | POST | 200 OK |
| 4. Check Inventory | `/inventories/{productId}` | GET | 200 OK |
| 5. Create Order (Happy) | `/orders` | POST | 200 OK |
| 6. Order Fails (No Stock) | `/orders` | POST | 400 Error |
| 7. Order Fails (Payment) | `/orders` | POST | 400 Error |
| 8. Concurrent Orders | `/orders` | POST (x2) | 200 + 400 |
| 9. Get Order Status | `/orders/{orderId}` | GET | 200 OK |
| 10. List Orders | `/orders` | GET | 200 OK |

---

## Implementation Order

1. **Phase 1:** Scenarios 1, 2, 3, 4 (Setup products + inventory)
2. **Phase 2:** Scenario 5 (Happy path order)
3. **Phase 3:** Scenarios 6, 7 (Failure handling + compensation)
4. **Phase 4:** Scenarios 8, 9, 10 (Concurrency + queries)
